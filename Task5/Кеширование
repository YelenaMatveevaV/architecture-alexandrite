Архитектурное решение по кешированию

1. Мотивация
Для решения проблем низкой скорости работы страниц MES и выполнения заказов предлагается многоуровневая стратегия кеширования.

Кеширование систем:
 1) mes api 
 2) mes 
 3) shop api
 4) crm

Ожидаемый результат:
 1) сокращение времени отклика страниц от 40%
 2) уменьшение нагрузки на БД для часто используемых запросов до 70%
 3) повышение отказоустойчивости при пиковых нагрузках

2. Предлагаемое решение
Состав решения по кешированию:
    Redis для централизованного кеширования, обеспечивает быстрый доступ к данным для всех микросервисов.
    HTTP-кешированию на уровне API Gateway для кэширования HTTP-ответов (например, JSON-данных) перед их отправкой клиенту, что минимизирует количество запросов к внутренним сервисам.

Особенности кеширования
    Redis Cache :
       Используется для централизованного кэширования данных, таких как список заказов и результаты расчетов.
       Ключ кэша может быть, например, "order_list_all" или "order_list_status_completed".
       Масштабируется горизонтально
    HTTP-кэширование :
       API Gateway кэширует HTTP-ответы для часто запрашиваемых эндпоинтов (например, GET /orders).
       При изменении данных (например, статуса заказа) кэш очищается через механизм инвалидации.
       API Gateway настраивается для больших нагрузок.
    Инвалидация кэша :
       При изменении данных все уровни кэширования (Redis и HTTP-кэш) очищаются, чтобы гарантировать актуальность данных.

Диаграмма с решением представлена в файле "Component_diagram_cash"

Объяснение обновленной схемы
    Добавление API Gateway :
       API Gateway добавлен как промежуточный слой между клиентом (Customer, Operator, Seller) и внутренними сервисами.
       API Gateway выполняет маршрутизацию запросов к соответствующим микросервисам.
    HTTP-кеширование на уровне API Gateway :
       API Gateway кэширует HTTP-ответы для часто запрашиваемых эндпоинтов (например, /orders, /orders/{id}).
       При повторном запросе к тому же эндпоинту ответ берется из кэша, минуя внутренние сервисы.
    Интеграция API Gateway с Redis :
       API Gateway использует Redis для хранения кэшированных HTTP-ответов.
       Это позволяет централизованно управлять кэшированием и инвалидировать кэш при изменении данных.
    Как работает HTTP-кеширование :
       Клиент отправляет запрос к API Gateway.
       API Gateway проверяет, есть ли ответ на этот запрос в Redis.
       Если данные есть в кэше, они возвращаются клиенту.
       Если данных нет, запрос перенаправляется к внутренним сервисам, а результат сохраняется в Redis.
       При изменении данных (например, статуса заказа) API Gateway очищает соответствующие записи в кэше.
    Пример использования :
       Запрос списка заказов (GET /orders) кэшируется в API Gateway.
       При изменении статуса заказа API Gateway получает уведомление через очередь сообщений (Messages Queue) и инвалидирует кэш.

3. Диаграмма последовательности действий по прохождению заказа
Файл "Sequence_diagram"

Объяснение диаграммы
1. Чтение списка заказов
 Запрос оператора :
  Оператор запрашивает список заказов через интерфейс MES.
 Проверка кэша :
  MES API проверяет, есть ли список заказов в кэше (Redis Cache).
  Если данные есть в кэше, они возвращаются немедленно.
 Запрос к базе данных :
  Если данных нет в кэше, MES API выполняет запрос к базе данных (MES DB).
  Результат запроса сохраняется в кэше с временем жизни (TTL), например, 5 минут.
 Отображение данных :
  Список заказов возвращается оператору через интерфейс MES.
2. Запись об изменении статуса заказа
 Изменение статуса :
  Оператор изменяет статус заказа (например, на MANUFACTURING_STARTED) через интерфейс MES.
 Инвалидация кэша :
  MES API инвалидирует (очищает) кэшированный список заказов в Redis Cache, чтобы гарантировать актуальность данных.
 Обновление базы данных :
  MES API обновляет статус заказа в базе данных (MES DB).
 Уведомление других систем :
  Уведомление об изменении статуса отправляется в очередь сообщений (Messages Queue).
  CRM API получает уведомление и также очищает кэш, если это необходимо.


6. Стратегия инвалидации кеша 

1) Временная инвалидация (TTL - Time to Live)
        Описание:
           Каждая запись в кэше имеет временной меткой (TTL), после истечения которой данные считаются устаревшими и автоматически удаляются.
           При запросе устаревших данных они обновляются из источника (например, базы данных).
        Примеры использования:
           Кэширование статических данных (например, списков товаров, конфигураций).
           Временные данные, которые редко изменяются (например, статистика за день).
        Плюсы стратегии:
           Простота реализации.
           Автоматическая очистка устаревших данных.
           Подходит для данных, которые не требуют мгновенного обновления.
        Минусы стратегии:
           Возможна задержка между изменением данных на сервере и их обновлением в кэше.
           Не подходит для данных, которые должны быть всегда актуальными.
        Особенности стратегии:
           TTL может быть установлен как глобально для всего кэша, так и индивидуально для каждой записи.
           Часто используется в сочетании с другими стратегиями (например, программной инвалидацией).

2) Инвалидация по ключу
        Описание:
           Каждая запись в кэше связана с уникальным ключом.
           При изменении данных на сервере соответствующий ключ удаляется или обновляется в кэше.
        Примеры использования:
           Кэширование заказов: при изменении статуса заказа ключ для этого заказа удаляется из кэша.
           Кэширование пользовательских данных: при обновлении профиля пользователя ключ для его данных инвалидируется.
        Плюсы стратегии:
           Гибкость: можно точно контролировать, какие данные нужно обновить.
           Быстрое обновление данных в кэше.
        Минусы стратегии:
           Сложность реализации: необходимо тщательно управлять ключами.
           Возможны ошибки при неправильном управлении ключами.
        Особенности стратегии:
           Подходит для систем с четко определенными данными, которые часто изменяются.
           Может использоваться в сочетании с временными метками (TTL) для дополнительной защиты от устаревания.

3) Программная инвалидация
        Описание:
           Инвалидация кэша выполняется явно через код или API.
           Например, при изменении данных на сервере вызывается функция для удаления или обновления соответствующих записей в кэше.
        Примеры использования:
           При создании нового заказа в Shop API вызывается функция для очистки кэша списка заказов.
           При изменении статуса заказа в MES API вызывается функция для обновления кэша статусов.
        Плюсы стратегии:
           Полный контроль над процессом инвалидации.
           Подходит для сложных сценариев, где требуется точное управление.
        Минусы стратегии:
           Высокая сложность реализации.
           Возможны ошибки при некорректной инвалидации.
        Особенности стратегии:
           Требует тесной интеграции между сервисами и кэшем.
           Часто используется в распределенных системах, где данные изменяются в разных микросервисах.

4) Write-Through (Через запись)
        Описание:
           Данные записываются одновременно в источник (например, базу данных) и в кэш.
           При чтении данных они всегда берутся из кэша.
        Примеры использования:
           Кэширование данных, которые часто читаются и редко изменяются (например, справочники, конфигурации).
        Плюсы стратегии:
           Гарантированная согласованность данных между кэшем и источником.
           Упрощение логики чтения данных.
        Минусы стратегии:
           Замедление операций записи, так как данные дублируются.
           Не подходит для данных, которые часто изменяются.
        Особенности стратегии:
           Используется в системах, где важна согласованность данных.
           Может быть комбинировано с временной инвалидацией.        

5) Cache-Aside (Рядом с кэшем)
        Описание:
           При запросе данных система сначала проверяет кэш.
           Если данных нет в кэше, они запрашиваются из источника и сохраняются в кэш.
           При изменении данных на сервере кэш не обновляется автоматически.           
        Примеры использования:
           Кэширование данных, которые редко изменяются (например, списки товаров)
        Плюсы стратегии:
           Простота реализации.
           Подходит для данных, которые редко изменяются.
        Минусы стратегии:
           Возможна задержка между изменением данных на сервере и их обновлением в кэше.
           Не гарантирует полную согласованность данных.
        Особенности стратегии:
           Часто используется в сочетании с временной инвалидацией (TTL).

6) Event-Driven инвалидация
        Описание:
           Инвалидация кэша происходит на основе событий (например, через очередь сообщений).
           При изменении данных на сервере публикуется событие, которое уведомляет кэш о необходимости обновления.
        Примеры использования:
           В архитектуре с RabbitMQ: при изменении статуса заказа в MES API публикуется событие, которое уведомляет Cache Subscriber об обновлении кэша.
        Плюсы стратегии:
           Гибкость: события могут быть обработаны асинхронно.
           Подходит для распределенных систем.
        Минусы стратегии:
           Сложность реализации.
           Возможны задержки при обработке событий.
        Особенности стратегии:
           Требует интеграции с очередью сообщений (например, RabbitMQ, Kafka).
           Часто используется в сочетании с другими стратегиями (например, инвалидацией по ключу)

7) Lazy Loading (Ленивая загрузка)
        Описание:
           Данные загружаются в кэш только при первом запросе.
           Если данные уже есть в кэше, они используются; если нет — запрашиваются из источника.
        Примеры использования:
           Кэширование данных, которые запрашиваются редко (например, исторические данные).
        Плюсы стратегии:
           Экономия ресурсов: данные загружаются только при необходимости.
           Простота реализации.
        Минусы стратегии:
           Первый запрос может быть медленным.
           Не подходит для данных, которые часто запрашиваются.
        Особенности стратегии:
           Часто используется в сочетании с временной инвалидацией (TTL).

8) Hybrid (Гибридная стратегия)
        Описание:
           Комбинация нескольких стратегий (например, временная инвалидация + инвалидация по ключу).
           Например, данные хранятся в кэше с TTL, но также могут быть инвалидированы программно при изменении.
        Примеры использования:
           Кэширование заказов: данные хранятся с TTL 5 минут, но при изменении статуса заказа ключ инвалидируется немедленно.
        Плюсы стратегии:
           Гибкость: можно комбинировать преимущества разных стратегий.
           Подходит для сложных сценариев.
        Минусы стратегии:
           Сложность реализации.
           Требует тщательного тестирования.
        Особенности стратегии:
           Часто используется в больших распределенных системах.


7. Дополнительное задание по сравнению решений

1) Клиентское кеширование (Client-Side Caching)
    Описание :
       Данные кэшируются на стороне клиента (например, в браузере или мобильном приложении).
       Это может быть реализовано с помощью HTTP-заголовков (например, Cache-Control, ETag).
       Кешировать данные на клиенте React/SWR с автоматическим ревалидированием при фокусе окна
    Диаграмма :
       Диаграмма с решением Client-Side Caching отображена в файле "Component_diagram_cash_Client-Side" с пояснением в файле "Component_diagram_cash_Client-Side_description"
    Пример использования :
       Список заказов или статусы заказов кэшируются в браузере оператора.
       При повторном запросе данные берутся из локального кэша, если они актуальны.
    Плюсы решения :
       Уменьшает нагрузку на сервер и сеть.
       Быстрый доступ к данным для пользователя.
    Минусы решения :
       Не подходит для частых изменений данных.
       Требует дополнительной настройки для инвалидации кэша.

2) Кэширование на уровне API Gateway
    Описание :
       API Gateway (например, Kong, Traefik или AWS API Gateway) может кэшировать ответы API перед их отправкой клиенту.
       Это особенно полезно для часто запрашиваемых данных, таких как список заказов.
    Пример использования :
       API Gateway кэширует ответы на запросы /orders или /orders/{id}.
       При обновлении статуса заказа кэш очищается через механизм инвалидации.
    Диаграмма :
       Диаграмма с решением кэширования на уровне API Gateway отображена в файле "Component_diagram_cash"
    Плюсы решения :
       Централизованное управление кэшированием.
       Уменьшает нагрузку на внутренние сервисы.
    Минусы решения :
       Может быть сложно настроить инвалидацию кэша.
       Подходит только для простых случаев.

3) Кэширование на уровне микросервисов (In-Memory Caching)
    Описание :
       Каждый микросервис (например, MES API или CRM API) использует собственный in-memory кэш для хранения часто запрашиваемых данных.
       Это может быть реализовано с помощью Redis, Memcached или даже внутреннего кэша приложения (например, Spring Cache для Java).
    Пример использования :
       MES API кэширует список заказов или результаты расчетов стоимости.
       При изменении статуса заказа микросервис инвалидирует соответствующие записи в кэше.
    Диаграмма :
       Диаграмма с решением In-Memory Caching отображена в файле "Component_diagram_cash_In-Memory" с пояснением в файле "Component_diagram_cash_In-Memory_description"
    Плюсы решения :
       Высокая скорость доступа к данным.
       Простота реализации для каждого микросервиса.
    Минусы решения :
       Разные микросервисы могут иметь несогласованные кэши.
       Требует дополнительной настройки для синхронизации кэшей.

4) Централизованное кэширование (Redis/Memcached)
    Описание :
       Все микросервисы используют единый централизованный кэш (например, Redis или Memcached).
       Это позволяет избежать дублирования данных и обеспечивает согласованность кэша.
    Пример использования :
       Redis используется для кэширования списка заказов, статусов заказов и других часто запрашиваемых данных.
       При изменении статуса заказа все микросервисы уведомляются об инвалидации кэша.
    Диаграмма :
       Диаграмма с решением централизованным кэшированием отображена в файле "Component_diagram_cash" 
    Плюсы решения :
       Единое хранилище данных для всех микросервисов.
       Легко настраивать и мониторить.
    Минусы решения :
       Вводится дополнительная зависимость от Redis/Memcached.
       Может стать узким местом при высокой нагрузке.

5) Write-Through, Write-Behind и Cache-Aside стратегии
    Write-Through (Через запись) :
       При изменении данных они одновременно обновляются в базе данных и в кэше.
       Это гарантирует, что кэш всегда содержит актуальные данные.
    Write-Behind (Запись потом) :
       При изменении данных они в кэше, а в базе данных данные обновляются потом асинхронно.
       Это гарантирует, что кэш всегда содержит актуальные данные.
       База данных не испытывает пиковых нагрузок, так как записи выполняются в фоновом режиме.
       Background Worker можно масштабировать горизонтально для обработки большого количества задач
    Cache-Aside (Рядом с кэшем) :
       Данные загружаются в кэш только при запросе.
       При изменении данных кэш очищается, и новые данные будут загружены при следующем запросе.
    Диаграмма :
       Диаграмма с решением Write-Through отображена в файле "Component_diagram_cash_Write-Through" с пояснением в файле "Component_diagram_cash_Write-Through_description"
       Диаграмма с решением Write-Behind отображена в файле "Component_diagram_cash_Write-Behind" с пояснением в файле "Component_diagram_cash_Write-Behind_description"
       Диаграмма с решением Cache-Aside отображена в файле "Component_diagram_cash_Cache-Aside" с пояснением в файле "Component_diagram_cash_Cache-Aside_description"
       
    Пример использования :
       MES API использует стратегию Cache-Aside для списка заказов.
       При изменении статуса заказа кэш очищается, и новые данные загружаются из базы данных.
       Расчёты цены и сложные бизнес-логики кешировать с использованием write-through или write-behind стратегий, чтобы минимизировать повторные вычисления.
       Стратегия Write-Behind идеально подходит для систем, где важна высокая производительность записи, а задержки синхронизации допустимы. 

    Плюсы решения :
       Write-Through: Данные всегда актуальны.
                     Упрощение инвалидации. Нет необходимости вручную инвалидировать кэш при изменении данных.                     
       Write-Behind: Данные актуальны и скорость обработки сведений не падает из-за ожидания записи в БД
       Cache-Aside: Простота реализации.
    Минусы решения :
       Write-Through: Увеличивает нагрузку на кэш.
                      Необходимо реализовать логику синхронизации между кэшем и базой данных.
       Write-Behind: Если Redis Cache выйдет из строя до того, как данные будут синхронизированы с базой данных, данные могут быть потеряны
                     Сложность реализации. Необходимо реализовать механизм обработки ошибок и повторных попыток синхронизации
                     Задержка синхронизации. Данные в базе данных могут временно отличаться от данных в кэше.
       Cache-Aside: Возможна задержка между обновлением данных и их появлением в кэше.

6) Распределенное кэширование (Distributed Caching)
    Описание :
       Используется распределенный кэш (например, Redis Cluster или Memcached Cluster), который позволяет масштабировать кэширование горизонтально.
       Это особенно полезно для больших объемов данных и высокой нагрузки.
    Пример использования :
       Redis Cluster используется для кэширования данных о заказах.
       При изменении статуса заказа все узлы кластера уведомляются об инвалидации кэша.
    Диаграмма :
       Диаграмма с решением Cache-Aside отображена в файле "Component_diagram_cash_Distributed" с пояснением в файле "Component_diagram_cash_Distributed_description"
    Плюсы решения :
       Масштабируемость.
       Высокая производительность.
    Минусы решения :
       Сложность настройки и управления.
       Требует дополнительных ресурсов.

7) Кэширование с использованием Event-Driven архитектуры
    Описание :
       При изменении данных (например, статуса заказа) событие публикуется в очередь сообщений (например, RabbitMQ или Kafka).
       Подписчики (например, микросервисы или кэш) реагируют на событие и обновляют свои данные.
    Пример использования :
       При изменении статуса заказа событие публикуется в RabbitMQ.
       MES API и CRM API подписываются на событие и инвалидируют свои кэши.
    Диаграмма :
       Диаграмма с решением Cache-Aside отображена в файле "Component_diagram_cash_Event-Driven" с пояснением в файле "Component_diagram_cash_Event-Driven_description"
    Плюсы решения :
       Гарантированная доставка событий.
       Минимальная задержка между обновлением данных и их появлением в кэше.
    Минусы решения :
       Сложность реализации.
       Требует настройки очередей сообщений.

8) Комбинированный подход
    Описание :
       Можно комбинировать несколько подходов для достижения оптимального результата.
       Например, использовать Redis для централизованного кэширования и HTTP-кеширование на уровне API Gateway.
    Пример использования :
       Redis используется для кэширования данных о заказах.
       API Gateway кэширует статические ответы (например, HTML-страницы).
       Event-Driven архитектура используется для инвалидации кэша.
    Диаграмма :
       Диаграмма с комбинированным решением отображена в файле "Component_diagram_cash_Event-Driven" с пояснением в файле "Component_diagram_cash_Event-Driven_description"
    Плюсы решения :
       Гибкость и масштабируемость.
       Высокая производительность.
    Минусы решения :
       Сложность внедрения и поддержки.

9) Кеширование данных СУБД
    Описание:
       Использовать материализованные представления.
       Внедрить пул соединений с кешированием запросов для повторяющихся операций
    Пример использования:
       В PostgreSQL создать материализованные view для сложных запросов (например, агрегированная статистика по заказам).
       Обновление по расписанию (каждые 5 мин) или через триггеры при изменениях.
       Пул соединений использовать при обработке проверки прав оператора.
    Диаграмма:
       Диаграмма с решением Cache-Aside отображена в файле "Component_diagram_cash_Mat_View" с пояснением в файле "Component_diagram_cash_Mat_View_description"
    Плюсы решения:
       Высокая производительность чтения
       Сложные запросы выполняются только при обновлении Materialized View, а не при каждом запросе
       Простота реализации, т.к. Materialized View поддерживается PostgreSQL
    Минусы решения:
       Если Materialized View обновляется по расписанию, данные могут быть неактуальными в момент запроса
       Materialized View занимает дополнительное место для хранения предварительно вычисленных данных
       Materialized View работает внутри одной базы данных и не подходит для распределенных систем

10) CDN для 3D файлов
    Описание:
       Для часто используемых 3D моделей и файлов реализовать локальный кеш на уровне MES API или Shop API, чтобы минимизировать сетевые запросы к S3 и ускорить доступ.
    Пример использования:
       Интегрировать CloudFront/S3 Acceleration для быстрой доставки статических 3D-моделей.
       Пререндер миниатюр моделей (256x256px) для ускорения отображения списков.
    Диаграмма:
       Диаграмма с решением CDN для 3D файлов отображена в файле "Component_diagram_cash_CDN_3D" с пояснением в файле "Component_diagram_cash_CDN_3D_description"
    Плюсы решения:
       Ускорение доступа к файлам
       Минимизация сетевых запросов
       Быстрое отображение списков
       Глобальная доставка контента
    Минусы решения:
       Требуется дополнительная настройка CDN, локального кэша и процесса пререндеринга миниатюр
       При изменении файла может возникнуть задержка перед его обновлением в CDN и локальном кэше
       Локальный кэш требует дополнительной памяти на серверах MES API и Shop API

11) Кеширование очереди сообщений
    Описание:
       Для очереди сообщений RabbitMQ можно внедрить кеширование состояний сообщений или результатов обработки, чтобы избежать повторной обработки и ускорить реакцию сервисов.
    Пример использования:
       Использование нового компонента Message Cache Subscriber, который подписывается на сообщения из очереди RabbitMQ.
    Диаграмма:
       Диаграмма с решением CDN для 3D файлов отображена в файле "Component_diagram_cash_Queue" с пояснением в файле "Component_diagram_cash_Queue_description"
    Плюсы решения:
       Устранение повторной обработки
       Ускорение реакции сервисов
       Снижение нагрузки на RabbitMQ
       Кэширование может быть настроено для различных типов сообщений и их состояний
    Минусы решения:   
       Если состояние сообщения изменяется, кэш должен быть своевременно инвалидирован
       Redis Cache требует дополнительных ресурсов для хранения состояний и результатов
       Сложность реализации

Заключение: 
Выбор подходящего варианта кеширования зависит от требований:
   Если нужна простота, то можно использовать Cache-Aside или Redis .
   Если важна масштабируемость, тто следует выбрать Redis Cluster или Event-Driven архитектуру .

Текущая архитектура хорошо подходит для внедрения Redis как централизованного кэша, так как он легко интегрируется с Kubernetes и микросервисами. 
Также можно добавить HTTP-кеширование на уровне API Gateway для дополнительной оптимизации.